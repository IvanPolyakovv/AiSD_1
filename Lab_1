// Polyakov Ivan 3372, Lab 1

#include <iostream>
#include <string>
#include <cstring>
#include <cmath>
#include <sstream>

using namespace std;

class DynamicArray {
private:
    double* data;
    int capacity;
    int size;

    void resize() {
        capacity *= 2;
        double* newData = new double[capacity];
        for (int i = 0; i < size; ++i) {
            newData[i] = data[i];
        }
        delete[] data;
        data = newData;
    }
public:
    DynamicArray() : size(0), capacity(2) {
        data = new double[capacity];
    }

    ~DynamicArray() {
        delete[] data;
    }

    void insert(int value) {
        if (size == capacity) {
            resize();
        }
        data[size++] = value;
    }

    void remove(int index) {
        if (index >= size) {
            cout << "Index out of range\n";
        }
        else
        {
            for (int i = index; i < size - 1; ++i) {
                data[i] = data[i + 1];
            }
            --size;
        }
    }

    double average() const {
        if (size == 0) {
            cout << "Array is empty\n";
        }
        else
        {
            double sum = 0;
            for (int i = 0; i < size; ++i) {
                sum += data[i];
            }
            return sum / size;
        }
    }

    void print() const {
        for (int i = 0; i < size; ++i) {
            std::cout << data[i] << " ";
        }
        cout << endl;
    }
};

class Node {
public:
    int data;
    Node* next;
    Node* prev;

    Node(int value) : data(value), next(nullptr), prev(nullptr) {}
};

class DoublyLinkedList {
private:
    Node* head;
    Node* tail;

public:
    DoublyLinkedList() : head(nullptr), tail(nullptr) {}

    ~DoublyLinkedList() {
        Node* current = head;
        while (current) {
            Node* nextNode = current->next;
            delete current;
            current = nextNode;
        }
    }

    void insertAtHead(int value) {
        Node* newNode = new Node(value);
        if (!head) {
            head = tail = newNode;
        }
        else {
            newNode->next = head;
            head->prev = newNode;
            head = newNode;
        }
    }

    void insertAtTail(int value) {
        Node* newNode = new Node(value);
        if (!tail) {
            head = tail = newNode;
        }
        else {
            tail->next = newNode;
            newNode->prev = tail;
            tail = newNode;
        }
    }

    void deleteNode(int value) {
        Node* current = head;
        while (current) {
            if (current->data == value) {
                if (current->prev) {
                    current->prev->next = current->next;
                }
                else {
                    head = current->next;
                }
                if (current->next) {
                    current->next->prev = current->prev;
                }
                else {
                    tail = current->prev;
                }
                delete current;
                return;
            }
            current = current->next;
        }
        std::cout << "Value " << value << " not found." << std::endl;
    }

    void displayForward() {
        Node* current = head;
        while (current) {
            std::cout << current->data << " ";
            current = current->next;
        }
        std::cout << std::endl;
    }

    void displayBackward() {
        Node* current = tail;
        while (current) {
            std::cout << current->data << " ";
            current = current->prev;
        }
        std::cout << std::endl;
    }
};

class Stack {
private:
    struct Node {
        string data;
        Node* next;
    };

    Node* topNode;

    // Вспомогательная рекурсивная функция для вывода элементов 
    void displayRecursively(Node* node) const {
    if (node == nullptr) {
        return; // Базовый случай: достигли конца стека 
    }
        displayRecursively(node->next); // Рекурсивный вызов для следующего элемента
        cout << node->data << " "; // Вывод данных после возврата из рекурсии 
    }


public:
    Stack() : topNode(nullptr) {}

    ~Stack() {
        while (!isEmpty()) {
            pop();
        }
    }

    void push(const string& value) {
        Node* newNode = new Node{ value, topNode };
        topNode = newNode;
    }

    string pop() {
        if (isEmpty()) {
            cout << "Stack is empty\n";
            return "";
        }
        else {
            Node* temp = topNode;
            string data = topNode->data;
            topNode = topNode->next;
            delete temp;
            return data;
        }
    }

    string top() const {
        if (isEmpty()) {
            cout << "Stack is empty\n";
            return "";
        }
        else {
            return topNode->data;
        }
    }

    bool isEmpty() const {
        return topNode == nullptr;
    }

    void display() const {
        cout << "Stack (bottom to top): ";
        displayRecursively(topNode); // Запускаем рекурсивный вывод
        cout << endl;
    }
};

bool isNumber(const string& s) {
    istringstream iss(s);
    double d;
    return (iss >> d) && (iss.eof());
}

int precedence(const string& op) {
    if (op == "+" || op == "-") {
        return 1;
    }
    else if (op == "*" || op == "/") {
        return 2;
    }
    else if (op == "^") {
        return 3; // Возведение в степень имеет более высокий приоритет 
    }
    else if (op == "sin" || op == "cos") {
        return 4; // Функции имеют самый высокий приоритет
    }
    return 0; // Неизвестный оператор
    }

void shuntingYard(const string& expression, Stack& output, Stack& operators) {
    istringstream iss(expression);
    string token;

    while (iss >> token) {
        if (isNumber(token)) {
            output.push(token);
        }
        else if (token == "+" || token == "-" || token == "*" || token == "/") {
            while (!operators.isEmpty() && precedence(operators.top()) >= precedence(token)) {
                output.push(operators.pop());
            }
            operators.push(token);
        }
        else if (token == "^")
        {
            while (!operators.isEmpty() && precedence(operators.top()) >= precedence(token)) {
                output.push(operators.pop());
            }
            operators.push(token);
        }
        else if (token == "sin" || token == "cos") {
            operators.push(token);
        }
        else if (token == "(") {
            operators.push(token);
        }
        else if (token == ")") {
            while (!operators.isEmpty() && operators.top() != "(") {
                output.push(operators.pop());
            }
            operators.pop(); // Удаляем '(' из стека
        }
    }

    while (!operators.isEmpty()) {
        output.push(operators.pop());
    }
}

    double evaluateRPN(Stack & output) {
        string expression = collectStackElements(output);
        cout << "RPN Expression: " << expression << endl;

        Stack stack;
        istringstream iss(expression);
        string token;

        while (iss >> token) {
            if (isNumber(token)) {
                stack.push(token);
            }
            else {
                double result = 0;

                if (token == "sin" || token == "cos") {
                    if (stack.isEmpty()) {
                        cout << "Error: Insufficient operands for operation " << token << endl;
                        return 0;
                    }

                    double operand = 0;
                    try {
                        operand = stod(stack.pop());
                    }
                    catch (const std::invalid_argument&) {
                        cout << "Error: Invalid number format for operand." << endl;
                        return 0;
                    }

                    if (token == "sin") {
                        result = sin(operand);
                    }
                    else if (token == "cos") {
                        result = cos(operand);
                    }
                }
                else {
                    if (stack.isEmpty()) {
                        cout << "Error: Insufficient operands for operation " << token << endl;
                        return 0;
                    }

                    double b = 0;
                    try {
                        b = stod(stack.pop());
                    }
                    catch (const std::invalid_argument&) {
                        cout << "Error: Invalid number format for operand." << endl;
                        return 0;
                    }

                    if (stack.isEmpty()) {
                        cout << "Error: Insufficient operands for operation " << token << endl;
                        return 0;
                    }

                    double a = 0;
                    try {
                        a = stod(stack.pop());
                    }
                    catch (const std::invalid_argument&) {
                        cout << "Error: Invalid number format for operand." << endl;
                        return 0;
                    }

                    if (token == "+") {
                        result = a + b;
                    }
                    else if (token == "-") {
                        result = a - b;
                    }
                    else if (token == "*") {
                        result = a * b;
                    }
                    else if (token == "/") {
                        if (b == 0) {
                            cout << "Error: Division by zero." << endl;
                            return 0;
                        }
                        result = a / b;
                    }
                    else if (token == "^") {
                        result = pow(a, b);
                    }
                    else {
                        cout << "Error: Unknown operator " << token << endl;
                        return 0;
                    }
                }

                stack.push(to_string(result));
            }
        }

        if (stack.isEmpty()) {
            cout << "Error: No result to return." << endl;
            return 0;
        }

        try {
            double finalResult = stod(stack.pop());
            cout << "Result: " << finalResult << endl;
            return finalResult;
        }
        catch (const std::invalid_argument&) {
            cout << "Error: Invalid number format in final result." << endl;
            return 0;
        }
    }

string collectStackElements(Stack& output) {
    if (output.isEmpty()) {
        return ""; // Базовый случай: стек пуст 
    }

        string token = output.pop(); // Извлекаем верхний элемент 
        string rest = collectStackElements(output); // Рекурсивно собираем оставшиеся элементы
        return rest + (rest.empty() ? "" : " ") + token; // Собираем строку
    }

int main()
{
    int choice = 0;
    do
    {
        cout << "1. Dynamic Array\n"
            << "2. Doubly Linked List\n"
            << "3. Stack\n"
            << "4. Sort Station\n"
            << "0. Exit\n";
        cout << "Enter your choice: ";
        cin >> choice;
        switch (choice)
        {
        case 0:
            return 0;
            break;
        case 1:
        {
            DynamicArray arr; // Создаем динамический массив
            int choiceArr, value, index;

            do {
                std::cout << "1. Insert element\n";
                std::cout << "2. Remove element\n";
                std::cout << "3. Calculate average\n";
                std::cout << "4. Print\n";
                std::cout << "0. Exit\n";
                std::cout << "Enter your choice: ";
                std::cin >> choiceArr;

                switch (choiceArr) {
                case 1:
                {
                    std::cout << "Enter the value: ";
                    std::cin >> value;
                    arr.insert(value);
                    break;
                }
                case 2:
                {
                    std::cout << "Enter the index: ";
                    std::cin >> index;
                    arr.remove(index);
                    break;
                }
                case 3:
                {
                    std::cout << "Average: " << arr.average() << std::endl;
                    break;
                }
                case 4:
                {
                    arr.print();
                    break;
                }
                case 0:
                    break;
                default:
                    std::cout << "Error!" << std::endl;
                }
            } while (choiceArr != 0);
            break;
        }
        case 2:
        {
            DoublyLinkedList list;
            int choiceList, value;

            do {
                std::cout << "\n1. Insert at Head\n"
                    "2. Insert at Tail\n"
                    "3. Delete Node\n"
                    "4. Display Forward\n"
                    "5. Display Backward\n"
                    "0. Exit\n"
                    "Enter the choice: ";

                std::cin >> choiceList;

                switch (choiceList) {
                case 1:
                    std::cout << "Enter value to insert at head: ";
                    std::cin >> value;
                    list.insertAtHead(value);
                    break;
                case 2:
                    std::cout << "Enter value to insert at tail: ";
                    std::cin >> value;
                    list.insertAtTail(value);
                    break;
                case 3:
                    std::cout << "Enter value to delete: ";
                    std::cin >> value;
                    list.deleteNode(value);
                    break;
                case 4:
                    std::cout << "List (Forward): ";
                    list.displayForward();
                    break;
                case 5:
                    std::cout << "List (Backward): ";
                    list.displayBackward();
                    break;
                case 0:
                    break;
                default:
                    std::cout << "Error.\n";
                    break;
                }
            } while (choiceList != 0);
            break;
        }
        case 3:
        {
            Stack stack;
            int choiceStack, value;

            do {
                std::cout << "1. Push\n";
                std::cout << "2. Pop\n";
                std::cout << "3. Top\n";
                std::cout << "4. Display\n";
                std::cout << "5. Check if empty\n";
                std::cout << "0. Exit\n";
                std::cout << "Enter your choice: ";
                std::cin >> choiceStack;

                switch (choiceStack) {
                case 1:
                    std::cout << "Enter value to push: ";
                    std::cin >> value;
                    stack.push(to_string(value));
                    break;
                case 2:
                    stack.pop();
                    std::cout << "Element popped from stack.\n";
                    break;
                case 3:
                    std::cout << "Top element: " << stack.top() << std::endl;

                    break;
                case 4:
                    stack.display();
                    break;
                case 5:
                    std::cout << (stack.isEmpty() ? "Stack is empty." : "Stack is not empty.") << std::endl;
                    break;
                case 0:
                    break;
                default:
                    std::cout << "Error.\n";
                }
            } while (choiceStack != 0);

            break;
        }
        case 4:
        {
            cin.ignore(numeric_limits<streamsize>::max(), '\n');

            while (true) {
                string expression;
                cout << "Enter the expression (exit): ";
                getline(cin, expression);
                if (expression == "exit") {
                    break;
                }
                else
                {
                    Stack operators;
                    Stack output;
                    shuntingYard(expression, output, operators);
                    evaluateRPN(output);
                }
            }
            break;
        }
        default:
            cout << "Error!\n";
        }
    } while (choice != 0);
}

